# CGRA-Flow Ideas

## 可能存在的问题

1. 目前在CGRA-Flow的设计中每个Tile每个时钟周期自动从控制存储器取一条指令执行，然而并非每个Tile在每个时钟周期都需要执行计算操作。所以有大量的无用（默认）指令填充配置存储器，导致CGRA中存放控制指令的配置存储器存储空间浪费。
2. 目前CGRA-Flow的模型是基于所有FU的操作都在一个时钟周期完成。这与事实不符。一些操作在一个时钟周期完成，会造成电路的大面积与高延时，一般不会选择这种方案。另外有些操作如访存操作需要的时钟周期很可能是不确定的。单周期的假设对FU的限制太大，框架应该能尽可能支持更多种类的FU，更加灵活。

## 解决思路思考

对CGRA框架进行修改，兼容各种多时钟周期的操作甚至是时钟周期数不太确定的情况，同时消除默认指令对存储空间的占用。  
准备对Tile中取指令执行的过程进行修改，从原来的每个时钟周期自动执行一条指令修改为当前节点需要的数据全部到达时再执行指令，并取出下条指令待用。这也是更加符合数据流思想的一种想法。这样就不用再存储大量的无用默认指令，每个Tile只需要存储需要真实执行的指令即可。  
原先Tile通过对时钟周期的计数值在配置存储器中寻址获得指令，可修改为对当前Tile已执行指令的计数值在配置存储器中寻址。  
由于指令是否执行与数据是否到达挂钩而不再与时钟周期挂钩，FU中的操作需要的时钟周期将不再受限制，修改后的框架就能够适应各种时钟周期的FU。  
需要对硬件和Mapper都进行修改，硬件和Mapper的修改设计还不清晰，这里先不提。  

## 小实验

主要是选了几个算法进行了Mapping，统计了由时钟驱动和由数据流驱动情况下指令数量的区别。  
此次采用的CGRA具有4x4共16个Tile且连接方式为CGRA-Mapper中默认连接方式，每个FU中所有操作都只需要一个时钟周期。将不同的算法通过相同参数进行映射。得到如下表所示的数据。  
<p float="center">
	<img src="https://github.com/chaozhang2000/CGRA-learning/blob/main/pic/data1.png" width="400" />
</p>

在得到的数据中，在时钟驱动的方案下，每个周期每个Tile需要一条指令当然其中有不少空指令，总指令数为周期数乘Tile的数量。在数据流驱动情况下由数据到达来驱动Tile取指令执行，总指令数等于单周期下总指令数除去空指令数后剩下的指令数。总指令数相比单周期的情况下普遍有减少。配置CGRA需要往CGRA的配置存储器中写入的指令减少，配置时间缩短。  
但是我也发现，在当前的Mapper算法下多周期的Tile最大指令数和单周期的每个Tile指令数（即周期数）基本相同，如果CGRA采用每个Tile中配置存储器容量相同的设计，则并不能减少对存储器容量的需求。但实际上目前是建立在所有FU执行所有操作都只需要一个时钟周期的假设下的，当FU执行操作的周期数增加，按照时钟驱动来进行映射所需要的周期数就会大大增加，导致每个Tile需要存储的指令数大大增加。   
我们也发现按照数据流驱动进行映射可能会出现每个Tile指令分布不均的问题，或许可以通过映射算法的修改时其趋于均匀，从而也可以缩小对每个Tile中指令存储器容量的需求。  